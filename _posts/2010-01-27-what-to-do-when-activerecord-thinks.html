--- 
name: what-to-do-when-activerecord-thinks
layout: post
title: What to do when ActiveRecord thinks an Oracle key is a decimal
time: 2010-01-27 09:10:00 -05:00
---
I recently created a model for an existing database table using the <a href="http://www.alexrothenberg.com/2009/11/generate-models-from-tables-legacy-data.html">legacy_data gem</a> and was confused when my primary key showed up in scientific notation.  It turned out the issue was due to sloppiness in the table definition and could be easily fixed once I understood what ActiveRecord was doing.<br /><br />I created a <code>Person</code> model connected to the <code>people</code> table<br /><br /><pre><br />class Person < ActiveRecord::Base<br />end<br /></pre><br /><br />but when I went into script/console the primary key showed up as a <code>BigDecimal</code> when I expected an <code>integer</code>.<br /><br /><pre><br />$ script/console <br />Loading development environment (Rails 2.3.4)<br />>> Person.first.id<br />=> #<BigDecimal:37378fc,'0.1002484442 5E11',12(16)><br /></pre><br /><br />This wasn't what I wanted and would cause problems in my app when it tried to build a url with that id like <code>http://localhost:3000/people/10024844425.0</code>.  The rails routing engine would see the .0, treat it as a format (like .xml or .json) and get confused.  Let's look at why this is happening.<br /><br /><br /><pre><br />>> Person.columns_hash['id']<br />=> #<ActiveRecord::ConnectionAdapters::OracleEnhancedColumn:0x37391c0 @default=nil, @type=:decimal, @null=true, @name="id", @table_name="people", @scale=nil, @sql_type="NUMBER", @precision=nil, @primary=true, @forced_column_type=nil, @limit=nil><br />>> Person.columns_hash['id'].type<br />=> :decimal<br />>> Person.columns_hash['id'].sql_type<br />=> "NUMBER"<br /></pre><br /><br />We see that ActiveRecord is treating this column as a <code>:decimal</code> because it's sql_type is <code>NUMBER</code>.  It turns out this is correct because an Oracle number is a decimal unless you specify it to have 0 digits after the decimal point (scale of 0).  Here's the <a href="http://download.oracle.com/docs/cd/B19306_01/server.102/b14220/datatype.htm#i16209">documentation from Oracle</a> (the last sentence is my bold)<br /><br /><pre><br />NUMBER Datatype<br /><br />The NUMBER datatype stores fixed and floating-point numbers. Numbers of virtually any magnitude can be stored and are guaranteed portable among different systems operating Oracle, up to 38 digits of precision.<br /><br />The following numbers can be stored in a NUMBER column:<br /><br />Positive numbers in the range 1 x 10-130 to 9.99...9 x 10125 with up to 38 significant digits<br /><br />Negative numbers from -1 x 10-130 to 9.99...99 x 10125 with up to 38 significant digits<br /><br />Zero<br /><br />Positive and negative infinity (generated only by importing from an Oracle Version 5 database)<br /><br />For numeric columns, you can specify the column as:<br /><br />column_name NUMBER <br /><br />Optionally, you can also specify a precision (total number of digits) and scale (number of digits to the right of the decimal point):<br /><br />column_name NUMBER (precision, scale) <br /><br />If a precision is not specified, the column stores values as given. If no scale is specified, the scale is zero.<br /><br />Oracle guarantees portability of numbers with a precision equal to or less than 38 digits. You can specify a scale and no precision:<br /><br />column_name NUMBER (*, scale) <br /><br />In this case, the precision is 38, and the specified scale is maintained.<br /><br /><b>When you specify numeric fields, it is a good idea to specify the precision and scale. This provides extra integrity checking on input.</b><br /></pre> <br /><br />Let's look in my database and sure enough the ID is a number<br /><br /><pre><br />$ sqlplus myusername/mypassword@localhost:1521/mydatabase.world<br /><br />SQL*Plus: Release 10.2.0.4.0 - Production on Wed Jan 27 09:15:09 2010<br /><br />Copyright (c) 1982, 2007, Oracle.  All Rights Reserved.<br /><br /><br />Connected to:<br />Oracle Database 10g Release 10.2.0.4.0 - Production<br /><br />SQL> desc people;<br /> Name        Null?    Type<br /> ----------------------------------------- -------- ----------------------------<br /> ID          NUMBER<br /> NAME          VARCHAR2(10)<br /><br /></pre><br /><br />If you are allowed to change your database you can create a migration like<br /><br /><pre><br />$ script/generate migration change_person_id_to_integer<br />STUBBING MckinseyLDAP<br />      exists  db/migrate<br />      create  db/migrate/20100127145747_change_person_id_to_integer.rb<br /></pre><br /><br />now edit the migration<br /><br /><pre><br />class ChangePersonIdToInteger < ActiveRecord::Migration<br />  def self.up<br />    change_column(:people, :id, :integer)  <br />  end<br />  def self.down<br />    change_column(:people, :id, :decimal)  <br />  end<br />end<br /></pre><br /><br />In my case there were other applications using this table and I was not allowed to change it so I implemented a fix in Ruby to tell my model to treat this column as an integer even though it was defined as a decimal in the database.<br /><br /><pre><br />#config/initializers/legacy_data_type_coercion.rb<br />module LegacyDataTypeCoercion<br />  def set_integer_columns *col_names<br />    col_names.each do |col_name|<br />      columns_hash[col_name.to_s].instance_eval do<br />        @type = :integer<br />      end<br />    end<br />  end<br />end<br />ActiveRecord::Base.extend(LegacyDataTypeCoercion)<br /><br /><br />#app/models/person.rb<br />class Person < ActiveRecord::Base<br />  set_integer_columns :id<br />end<br /></pre><br /><br />We defined a method <code>set_integer_columns</code> that will force ActiveRecord to treat the columns we specify as integers.  In our Person model we declare  <code>:id</code> is an integer column.  Let's test it out!<br /><br /><pre><br />$ script/console <br />Loading development environment (Rails 2.3.4)<br />>> Person.first.id<br />=> 10024844425<br />>> Person.columns_hash['id'].type<br />=> :integer<br /></pre><br /><br />Just as expected id is now an integer and we can go ahead building the rest of our application.<br /><br />This is not an issue with all Oracle tables as if the column was defined as <code>NUMBER(10)</code> (with a precision and implicit scale of 0) then ActiveRecord will interpret it as an integer automatically based on the parentheses in the data type - i.e NUMBER(10) <a href="http://github.com/rails/rails/blob/master/activerecord/lib/active_record/connection_adapters/abstract/schema_definitions.rb#L224-238">ActiveRecord</a> or <a href="http://github.com/rsim/oracle-enhanced/blob/master/lib/active_record/connection_adapters/oracle_enhanced_adapter.rb#L192-197">Oracle Enhanced</a>).<div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/86313661235162475-5327631245171651344?l=www.alexrothenberg.com' alt='' /></div>
